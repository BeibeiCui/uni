\chapter{Conclusions \ToDo{and future work}} \label{chapter:conclusions}
%In the present work we propose a novel approach for matching graph based on the divide-and-conquer paradigm.
The present master thesis addresses the problem of graph matching and its application for finding correspondences between points on two images. The task of the graph matching problem is to find a mapping between node set of one graph and node set of the other graph that satisfies some predefined conditions. In the chapter~\ref{chapter:GM} we formally define the graph matching problem. 
% together with its variations. 
Additionally we provide an extensive overview of classical and recent algorithms for solving graph matching problems exactly and inexactly. 

%One distinguishes exact and inexact graph matching. The first is often too strict and therefore not suitable for practical applications. Therefore the main interest of the researchers lies on the inexact case.

%The most general formulation of graph matching problem uses a so-called affinity matrix to measure similarity between two graphs. 
The most general formulation of a graph matching problem uses a so-called affinity matrix to measure similarity between two graphs. 
As it has been shown, this problem formulation represents a special case of the quadratic assignment problem, which is known to be NP-hard. Due to the big size of the affinity matrix most of the existing graph matching algorithms, which use this formulation, become fast intractable for relatively small\footnote{The exact size of the graphs, that still can be handled by those algorithms, depends on the used implementation and on the hardware they are executed on. The used implementation of RRWM was able to match graphs with roughly up to $150$ nodes each.} graphs due to time and memory demands. Due to that reason we have suggested a framework (2LevelGM), which allows the application of existing algorithms to bigger graphs. The detailed explanation of the proposed technique is given in chapter~\ref{chapter:2levelGM}. There we have presented a two level graph matching algorithm, which is based on the well known divide-and-conquer paradigm. Initially provided graphs represent the lower level in our matching schema. To reduce the problem size we have replaced initial graphs by new smaller graphs (anchor graphs), which we have placed on the higher level. Each node (anchor) of such a graph represents a subgraph of the corresponding initial graph. Given such a two level structure our method proceeds as follows:
\begin{enumerate}
\item it finds correspondences between nodes of the anchors graphs (higher level);
\item finds for each pair of matched anchors a mapping between the nodes of the underlying subgraphs (lower level);
\item updates subgraphs;
\item runs further through steps $1-3$ until it does not achieve any improvement in the overall solution in several successive iterations.
\end{enumerate}
Under an overall solution we understand a union of the local solutions of the subproblems. To perform matching between anchor graphs and subgraphs of the initial graphs we have used the Reweighted Random Walk algorithm~\cite{Cho2010_RRWM}.

For partitioning the initial graph we have suggested two methods. The first one lays a grid with a fixed number of cells over the graphs and captures nodes inside one cell into one cluster. The second method iteratively replaces edges in the independent edge sets of the initial graphs with a single node until the desirable size of graphs is reached. Generally any other partition method can be used instead. However, there is one requirement to a selected partition method: it should create similar anchor graphs for similar initial graphs. Both of the proposed techniques have approved themselves to be able to guaranty this requirement. However, we have noticed, that the second method tends to create more anchors in the areas of high node density in the original graph. As a result if the initial graphs have different regions of high node density the resulting anchor graphs could be substantially different.

On the higher level we have matched the anchor graphs again by using a similarity matrix between anchor graphs. To calculate it we have proposed a technique for defining anchor attributes. Alternatively one can use the matching score of the underlying subgraphs. 

To improve the initial partition we have suggested an update procedure, which allows the existing subgraphs to exchange nodes with their neighbors based on the current matching solution. The formulated update rule is based on the consideration, that in case of correct matching locally connected groups of nodes should underlie the same local transformation, which we assumed to be affine.

%In chapter \ref{chapter:results} we have evaluated the efficiency of proposed framework on some synthetic graphs and real image examples.
How well the proposed framework works is evaluated in chapter \ref{chapter:results} on some synthetic graphs and real image examples. We have performed a comparison with the different state-of-the-art algorithms (RRWM~\cite{Cho2010_RRWM}, MPM~\cite{Cho2014_Haystack}, SM~\cite{Leordeanu2005_SM}, IPFP~\cite{Leordeanu2009_IPFP}, GLAG~\cite{Fiori2013_GLAG}, PATH~\cite{Zazlavskiy2008_PATH} and ProgGM~\cite{Cho2012_ProgressiveGM}) and reported the results of matching by measuring the reached objective score, the accuracy of the obtained solution and the required running time. After summarizing the results of different tests we came to the following conclusions:
\begin{itemize}
\item The usage of anchor attributes for anchor graph matching is preferred, as it improves the runtime performance of our approach. 
% With it our approach has clearly better runtime performance, as with graph matching score in the role of similarity value between anchors.
When using attributed anchor graphs, 2levelGM was in most cases at least exactly as fast as the other algorithms or even faster, when running on graphs with up to $600$ nodes. The only one exception is ProgGM, which is faster compared to 2LevelGM. However ProgGM considers one reduced version of an initial matching problem, where we create a whole set of smaller subproblems. Consequently, the reason for better running time lies in the fact, that we solve summary more graph matching problems.
\item The both ways to match anchor graphs lead to similar results in accuracy and objective score. Although, we have to admit, that the defined structure based attributes, when they are used alone, are susceptible to graph deformations and causes some instability issues in the matching results. This instability probably comes from sometimes wrongly matched anchors.
\item In case of (sub)graph isomorphism problems, our approach shows nice results. In single runs it performs on the same level as RRWM, MPM, IPFP, when applied to graphs, which still can be matched directly with those algorithms. However due to some stability issues in its performance the averaged values are a little bit lower than those of the mentioned algorithms. For graphs with up to $600$ nodes, our approach outperforms both GLAG and PATH algorithms, that use a less memory demand formulation of the graph matching problem.
\item 2LevelGM has a less good accuracy and objective score on graphs with high deformation rate, which however is also the case for most of the other algorithms. In case of smaller graphs and the usage of subgraph matching to compare anchor graphs, the results achieved with 2LevelGM are close to those of RRWM and therefore are better than those of MPM. The usage of anchor attributes in this case decreases the matching quality of our approach.  This happens likely because the defined anchor attributes do not provide enough resistance against structural deformation. In case of bigger graphs 2LevelGM showed better results than GLAG and PATH also in presence of small deformation in the structure of one of the graphs.
\item Applied to the problem of matching synthetically generated image pairs, where one image represent a rotated and/or translated copy of the other one, 2LevelGM showed very good results.
%Notice, that in this case we solve again a (sub)graph isomorphism problem.
Those examples demonstrate the usefulness of the proposed subgraph update rule.
\item Evaluation on the CMU House sequence~\cite{CMUHouse} shows, that 2LevelGM has troubles with the matching of image pairs with non-affine transformation between them.
\item In comparison with GLAG and PATH 2LevelGM shows big potential to be applied to really big graphs.
\end{itemize}

Based on the obtained results we can conclude that 2LevelGM allows its further improvement. Although this improvement lies beyond the scope of the present work, it could be made in the future works. Possible ways of further development are shortly given below.

Based on the made conclusions we have several thought how 2LevelGM can be improved in a future work. %, that we were not able to integrate in our work due to time limitations .

The method probably can be further improved by adopting more sophisticated graph partitioning techniques. Ideally, we would like to cluster two graphs jointly to guaranty better matching after the first iteration. There are some techniques, that solve this problem in case of a provided information about correct matches between some nodes, however we did not see similar algorithms for an completely unsupervised case.

We also believe, that the defined anchor attributes can be further improved. One of possible ways is to include not only length information of the edges in the underlying subgraphs, but also angles. A further improvement could be to connect results of the anchor matching in the successive iterations of the algorithm to improve its quality.

Since our current update rule is less effective in case of non-affine transformation between matched clusters, we have tried to improve it already during our work on the thesis vie the estimation of non-rigid transformation. However achieved improvement of 2LevelGM is not significant in case of the CMU House sequence. We suppose, that the reason for this lies in the fact, that our subgraphs are too big for estimating a one common transformation for all nodes inside them. Therefore a next step of the improvement could be a subdivision of matched subgraphs into smaller groups of nodes, which have similar transformations.

Currently, the performance of 2LevelGM depends strongly on the selected parameters, such as number of anchors, number of clusters to create a codebook of node attributes and so on. In future one can think about a way to parameter reduction or an automatic selection their best suitable values depending on a given problem. % We also left for the future 

Concerning future work it would be interesting to generalize the proposed framework using a probabilistic matching framework. Further tests on graphs bigger than those, which were considered in this thesis, can be performed as well. However for the better performance the current two level approach should be extended to an hierarchical one. The reason for this is the following consideration. To preserve subgraph problems sufficiently small one needs to increase the number of anchors. Consequently on some point the anchor graphs will become too big to be matched directly and need to be subdivided into smaller subproblems to perform further. According to the seen results of comparison we are right to expect, that a hierarchical modification of our two level framework will show good matching results and time performance. 
% and think that proposed in this thesis techniques are worth for further research.
Our results should be considered as completed important stage that gives a base for further development and research.

 
