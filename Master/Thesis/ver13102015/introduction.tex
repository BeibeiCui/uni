\chapter{Introduction}
The graph theory is one of the oldest and widely used branches of the discrete mathematics. Graphs have found an application in almost all fields of the computer science including image processing and computer vision. The reason for such a success is their simple way to model pairwise relationships between different objects. In terms of image processing and computer vision those objects can be presented by image regions, image features or even separate pixels. Such graph representation helps often to transform an existing practical problem into good investigated problem of graph theory. An example, one of the central problems in computer vision -- image matching. %object recognition.
Using a graph representation of images, which, for example, can be obtained by connection selected points on the images with edges, this problem can be formulated as a graph matching problem. Although the last is not easy to solve (the most of graph matching problems are known to be NP-hard), there are a lot of approximative algorithms, that solve it in polynomial time.

Further in this work we will see, that one distinguishes two general types of graph matching problems: exact and inexact one. As the exact problems are often too strict to be applied to practical applications, such as image matching, we concentrate our selfs on the algorithms, that solve graph matching problem inexact.
In the most general case, those algorithms use so-called affinity or similarity matrix of two graphs, which contains an information how similar two graphs are.
However in naive implementation those algorithms have strong limitations on the size of the graphs they can handle in reasonable time due to high time and memory demand. Knowing this issues the aim of this thesis is to present a novel framework that should help to extend the usability of the existing graph matching algorithms to bigger graphs. The proposed framework helps to reduce the complexity of the problem by subdividing it into a smaller problems, that can be easily handled with existing algorithms. This technique can be seen as an adoption of the well known divide-and-conquer paradigm to the graph matching.

This thesis are organized we follows. In the chapter~\ref{chapter:GM} we give the general formulation of the graph matching problem together with its variations. We show different ways how to formulate the graph matching problem and how different formulations are related to each other. Additionally, we provide an extensive overview of existing algorithms for solving graph matching problems, which contains classical widely known works as well as recently published researches in the field.
The chapter~\ref{chapter:2levelGM} describes the novel two level graph matching framework based on the divide-and-conquer paradigm. %We explain in detail each single step of the purposed technique and . 
In the chapter~\ref{chapter:results} we report results of the evaluation of the proposed framework on synthetic generated graphs and real images. The last chapter gives a summary of the achieved results. There we also talk about possible improvements of the developed framework and future work.

%Unfortunately, most of the existing algorithms are not suitable to work with bigger  Experiments in most of the papers consider graphs with up to $100$ nodes \cite{Cho2014_Haystack, Cho2010_RRWM, Cho2012_ProgressiveGM}.
%
%%In the present work we propose a novel approach for matching graph based on the divide-and-conquer paradigm.
%The present master thesis addresses the problem of graph matching and its application for finding correspondences between points on two images.  The task of the graph matching problem is to find a mapping between node set of the one graph into node set of the other graph that satisfies some conditions. In the chapter~\ref{chapter:GM} we give the general formulation of the graph matching problem together with its variations. Often the graph matching problems are subdivided into two groups: exact and inexact matching. As we saw, problems in the first group are to strict to be applied to real world problems. For that reason we focus on the second group, where graph matching is formulated as an optimization problem. We show different ways how to formulate this optimization problem and how those formulations are related to each other. Additionally, we provide in chapter~\ref{chapter:GM} an extensive overview of the resent algorithms for solving inexact graph matching problems. 
%
%The most general formulation of graph matching problem uses a so-called affinity matrix to measure similarity between two graphs. As it has been shown, this problem formulation represents a special case of quadratic assignment problem, which is known to be NP-hard. Due to the big size of the affinity matrix most of existing graph matching algorithms, that use this formulation, are not suitable to work fast on graphs with more than $100$ nodes each. For that reason, we suggest a framework, which allows the application of existing algorithms to bigger graphs. The detailed explanation of the proposed technique is given in the chapter~\ref{chapter:2levelGM}. Our idea is based on the well known divide-and-conquer paradigm. We subdivide a given graph matching problem, which is too big to be solved directly, into a set of non-overlapping smaller problems. This is done in a way, that each single subproblem can be solved fast with the existing methods. An overall solution is represented by a combination of the local solutions of the subproblem. 
%Each sub
%To partition graph we suggest two methods. The first one puts a grid with fix number of cells over the graphs and captures nodes inside one cell into one cluster. The second method iteratively replaces edges in the independent edge sets of the graphs with a single node until the desirable size of graphs is reached. Generally, each other partition method can be used. However, our main requirement to it is, that it should create
%
%As a partition of the initial graphs into non-overlapping subgraphs has obviously a great impact on the quality of the solution, we suggest an update rule, whose aim is to improve existing partition using obtained correspondences between nodes of two graphs.
%
%our approach iteratively tries to improve initial subdivision of the graphs and matches again the subproblems. The update rule 
%
%
%It continuous until we do not achieve an improvement in several successive iterations.
%
%
% A resulting solution is then combined from local solutions of single subproblems. A disadvantage of such an approach is however, that a runtime improvement is sometimes paid with a drop in the accuracy.
%Due to that, one want to have a trade off between speed up and accuracy. What is more important depends on a particular problem.