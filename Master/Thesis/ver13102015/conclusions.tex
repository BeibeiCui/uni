\chapter{Conclusions and future work} \label{chapter:conclusions}
%In the present work we propose a novel approach for matching graph based on the divide-and-conquer paradigm.
The present master thesis addresses the problem of graph matching and its application for finding correspondences between points on two images. The task of the graph matching problem is to find a mapping between node set of the one graph into node set of the other graph that satisfies some predefined conditions. In the chapter~\ref{chapter:GM} we formally define the graph matching problem together with its variations. Additionally, we provide an extensive overview of the classical and recent algorithms for solving different graph matching problems. 

%One distinguishes exact and inexact graph matching. The first is often too strict and therefore not suitable for practical applications. Therefore the main interest of the researchers lies on the inexact case.

The most general formulation of graph matching problem uses a so-called affinity matrix to measure similarity between two graphs. As it has been shown, this problem formulation represents a special case of quadratic assignment problem, which is known to be NP-hard. Due to the big size of the affinity matrix most of existing graph matching algorithms, that use this formulation, become fast intractable for relative small\footnote{The exact size of the graphs, that still can be handled by those algorithms, depends on the used implementation and on the hardware they are executed on. The used implementation of RRWM was able to match graphs with roughly up to $150$ nodes each.} graphs due to time and memory demand. For that reason, we suggest a framework, which allows the application of existing algorithms to bigger graphs. The detailed explanation of the proposed technique is given in the chapter~\ref{chapter:2levelGM}. There we present a two level graph matching algorithm, which is based on the well known divide-and-conquer paradigm. Initially provided graphs represent the lower level in our matching schema. To reduce the problem size we replace initial graphs by another smaller graphs (anchor graphs), which we place on the higher level. Each node (anchor) of such graph represents a subgraph of the corresponding initial graph. Given such two level structure our method proceeds we follows:
\begin{enumerate}
\item it finds correspondences between nodes of the anchors graphs (higher level);
\item finds for each pair of matched anchors a mapping between the nodes of the underlying subgraphs (lower level);
\item updates subgraphs;
\item runs further through the same steps $1-3$ until it does not achieve any improvement in the overall solution in several successive iterations.
\end{enumerate}
Under overall solution we understand a union of the local solutions of the subproblems. To perform matching between anchor graphs and subgraphs of the initial graphs we use Reweighted Random Walk algorithm~\cite{Cho2010_RRWM}.

To partition the initial graph we suggest two methods. The first one puts a grid with fix number of cells over the graphs and captures nodes inside one cell into one cluster. The second method iteratively replaces edges in the independent edge sets of the initial graphs with a single node until the desirable size of graphs is reached. Generally, each other partition method can be used. However, our main requirement to it is, that it should create similar anchor graphs for similar initial graphs. Both of the proposed techniques have approved them selfs to be able to guaranty this property. However, we noticed, that the second method tends to creates more anchors in the areas of high node density in original graph. As a result, if the initial graphs have different regions of high node density the resulting anchor graphs could be very different.

On the higher level we match the anchor graphs again by using a similarity matrix between anchor graphs. To calculate it we propose a technique for defining anchor attributes. Alternatively one can use the matching score of the underlying subgraphs. 

To improve subgraphs we suggest an update procedure, which allows the existing subgraphs to exchange nodes with their neighbors based on the current matching solution. The formulated update rule is based on the consideration, that in case of correct matching locally connected groups of nodes should underlie the same local transformation, which we assume to be affine.

How well does the proposed framework work is evaluated on some synthetic graphs and real image examples in chapter \ref{chapter:results}. We perform a comparison with different state-of-the-art algorithms (RRWM~\cite{Cho2010_RRWM}, MPM~\cite{Cho2014_Haystack}, SM~\cite{Leordeanu2005_SM}, IPFP~\cite{Leordeanu2009_IPFP}, GLAG~\cite{Fiori2013_GLAG}, PATH~\cite{Zazlavskiy2008_PATH} and ProgGM~\cite{Cho2012_ProgressiveGM}) and report the results of matching by measuring reached objective score, accuracy of obtained solution and required running time. After summarizing the results of different tests we come to the following conclusions:
\begin{itemize}
\item The usage of anchor attributes for anchor graph matching is preferred. With it our approach has clearly better runtime performance, as with graph matching score in the role of similarity value between anchors. When using attributed anchor graphs, our two level graph matching was in the most cases at least exactly so fast, as the other algorithms or even faster, when running on the graphs with up to $600$ nodes. The only one exception is ProgGM, that is faster than our algorithm. How ever the ProgGM considers one reduced version of an initial matching problem, where we create a whole set of smaller subproblems. So the reason for better running time lies in the fact, that we solve summary more graph matching problems.
\item The both ways to match anchor graphs lead to the similar results in the accuracy and objective score. Although, we have to admit, that the defined structure based attributes, when used alone, are susceptible to graph deformations and causes some instability issues in the matching results, which probably comes from sometimes wrongly matched anchors.
\item In case of (sub)graph isomorphism problems, our approach shows nice results. In single run it performs on the same level as RRWM, MPM, IPFP, when applied to graphs, which still can be matched directly with those algorithms. However due to some stability issues in its performance the averaged values are a little bit lower than those of the mentioned algorithms. When applied to the graphs with up to $600$ nodes, our approach outperforms both GLAG and PATH algorithms, that use a less memory demand formulation of the graph matching problem.
\item The proposed two level matching approach has a less good accuracy and objective score on graphs with high deformation rate, which however is also the case for the most of the other algorithms. In case of smaller graphs and the usage of subgraph matching to compare anchor graphs, the results achieved with 2LevelGM are close to those of RRWM and therefore better than of MPM. The usage of the anchor attributes in this case decreases the matching quality of our approach.  This happens likely because the defined anchor attributes do not provide enough resistance against structural deformation. In case of bigger graphs 2LevelGM showed better results than GLAG and PATH also in presence of small deformation in the structure of one of the graphs.
\item Applied to the problem of matching synthetically generated image pairs, where one image represent a rotated and/translated copy of the other one, the two level graph matching algorithm showed very good results.
%Notice, that in this case we solve again a (sub)graph isomorphism problem.
Those examples demonstrate the usefulness of the proposed subgraph update rule.
\item Evaluation on the CMU House sequence~\cite{CMUHouse} shows, that our algorithm has issues with the matching of image pairs with non-affine transformation between them.
\item Comparison with GLAG and PATH show big potential of our algorithm to be applied on the really big graphs.
\end{itemize}

Based on the made conclusions we have several thought how to improve the proposed two level matching framework in the future work, that we were not able to integrate in our work due to time limitations .

The method probably can be further improved by adopting more sophisticated graph partitioning techniques. Ideally, we would like to cluster two graphs jointly to guaranty better matching after the first iteration. There are some techniques, that solve this problem in case of a provided information about correct matches between some nodes, however we did not see similar algorithms for completely unsupervised case.

We also believe, that the defined anchor attributes can be further improved. For example, by including not only length information of the edges in the underlying subgraphs, but also angels. A further improvement could be to connect results of the anchor matching in the successive iterations of the algorithm to improve its quality.

Since our current update rule is less effective in case of non-affine transformation between matched clusters, we have tried to improve it already during our work on the thesis by estimation of non-rigid transformation. However it did not improved the performance of 2LevelGM in case of the CMU House sequence much. We suppose, that the reason for that lies in the fact, that our subgraphs are too big for estimating a one common transformation for all node inside them. So a next step of the improvement could be subdivision of matched subgraphs into smaller groups of nodes, that underlie similar transformations.

Currently, the performance of 2LevelGM depends strongly on the selected parameters, such as number of anchors, number of cluster to create a codebook of node attributes and so on. In future one can think about a way to parameter reduction or an automatic selection their best suitable values depending on a given problem. % We also left for the future 

Concerning future work it would be interesting to generalize the proposed framework using probabilistic matching framework. We also would like to perform further tests on graphs bigger than those, that were considered in this thesis. However, for the better performance we should extend the current two level approach to an hierarchical one. The reason for this is the following consideration. To preserve subgraph problems sufficiently small we need to increase the number of anchor. Consequently, on some point the anchor graphs will become too big to be matched directly and need to be subdivided into problems to perform further. According to the seen results of comparison we are right to expect, that a hierarchical modification of our two level framework will show good matching results and time performance, and think that proposed in this thesis techniques are worth for further research.

 
